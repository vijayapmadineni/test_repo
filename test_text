
Analyze Table Bloat:
SELECT
    schemaname,
    relname AS tablename,
    pg_size_pretty(pg_relation_size(relid)) AS total_size,
    pg_size_pretty(pgstattuple.relpages * 8192) AS live_data,
    pg_size_pretty(pgstattuple.dead_tuple_len) AS dead_tuples,
    pgstattuple.dead_tuple_percent AS dead_tuple_percent
FROM
    pg_stat_all_tables
JOIN
    pgstattuple((schemaname || '.' || relname)::regclass) AS pgstattuple
WHERE
    schemaname NOT IN ('pg_catalog', 'information_schema')
ORDER BY
    pgstattuple.dead_tuple_percent DESC
LIMIT 10;


Analyze Index Bloat:

SELECT
    schemaname,
    relname AS indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS total_size,
    pg_size_pretty(pgstattuple.dead_tuple_len) AS dead_tuples,
    pgstattuple.dead_tuple_percent AS dead_tuple_percent
FROM
    pg_stat_all_indexes
JOIN
    pgstattuple((schemaname || '.' || indexrelname)::regclass) AS pgstattuple
WHERE
    schemaname NOT IN ('pg_catalog', 'information_schema')
ORDER BY
    pgstattuple.dead_tuple_percent DESC
LIMIT 10;




Using pg_bloat_check (Automated and Comprehensive)
pg_bloat_check is a script that estimates bloat in tables and indexes by analyzing system catalogs and applying a bloat formula. You do not need to install it in the database; it can be run as a script using SQL queries.


WITH bloat_data AS (
    SELECT
        schemaname,
        tablename,
        reltuples AS estimated_rows,
        relpages AS pages,
        pg_relation_size(relid) AS table_size,
        pg_total_relation_size(relid) AS total_size,
        pg_total_relation_size(relid) - pg_relation_size(relid) AS bloat_size,
        CASE
            WHEN pg_relation_size(relid) > 0 THEN
                (pg_total_relation_size(relid) - pg_relation_size(relid)) * 100.0 / pg_total_relation_size(relid)
            ELSE 0
        END AS bloat_percent
    FROM
        pg_stat_all_tables
    JOIN
        pg_class ON relid = pg_class.oid
    WHERE
        schemaname NOT IN ('pg_catalog', 'information_schema')
)
SELECT
    schemaname,
    tablename,
    pg_size_pretty(table_size) AS table_size,
    pg_size_pretty(bloat_size) AS bloat_size,
    bloat_percent
FROM
    bloat_data
WHERE
    bloat_percent > 10 -- Threshold for bloat
ORDER BY
    bloat_percent DESC;

for index:

WITH index_bloat AS (
    SELECT
        schemaname,
        indexrelname AS indexname,
        reltuples AS estimated_rows,
        pg_relation_size(indexrelid) AS index_size,
        pg_relation_size(indexrelid) - (pg_stat.get_live_tuples(indexrelid) * pg_index_tuple_estimate(indexrelid)) AS bloat_size,
        CASE
            WHEN pg_relation_size(indexrelid) > 0 THEN
                (pg_relation_size(indexrelid) - (pg_stat.get_live_tuples(indexrelid) * pg_index_tuple_estimate(indexrelid))) * 100.0 / pg_relation_size(indexrelid)
            ELSE 0
        END AS bloat_percent
    FROM
        pg_stat_all_indexes
    JOIN
        pg_class c ON c.oid = indexrelid
    WHERE
        schemaname NOT IN ('pg_catalog', 'information_schema')
)
SELECT
    schemaname,
    indexname,
    pg_size_pretty(index_size) AS index_size,
    pg_size_pretty(bloat_size) AS bloat_size,
    bloat_percent
FROM
    index_bloat
WHERE
    bloat_percent > 10 -- Threshold for bloat
ORDER BY
    bloat_percent DESC;


Use Built-In Views for Quick Estimation
If installing extensions is not allowed and you need an approximate result:

Use pg_stat_all_tables, pg_stat_all_indexes, and size functions (pg_table_size, pg_total_relation_size).

SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_table_size(relid)) AS total_size,
    pg_size_pretty(pg_total_relation_size(relid) - pg_table_size(relid)) AS bloat_size,
    CASE
        WHEN pg_table_size(relid) > 0 THEN
            (pg_total_relation_size(relid) - pg_table_size(relid)) * 100.0 / pg_table_size(relid)
        ELSE 0
    END AS bloat_percentage
FROM
    pg_stat_all_tables
WHERE
    schemaname NOT IN ('pg_catalog', 'information_schema')
ORDER BY
    bloat_percentage DESC
LIMIT 10;


VACUUM FULL schema1.tablename;
REINDEX INDEX schema1.indexname;

SELECT
    schemaname,
    relname AS tablename,
    indexrelname AS indexname,
    idx_scan AS index_scans
FROM
    pg_stat_user_indexes
WHERE
    idx_scan = 0; -- Never used


Best Practices for Long-Term Maintenance
Enable Autovacuum: Ensure autovacuum is running and configured properly.
Schedule Regular Maintenance:
Use VACUUM, ANALYZE, and REINDEX at off-peak hours.
Monitor Storage Usage:
Use pg_stat_all_tables, pg_stat_all_indexes, and pgstattuple regularly.
Archive Old Data: Move old data to separate tables or databases.
Using pgstattuple is the most accurate, but if extensions are restricted, rely on approximate catalog-based queries with manual fixes (VACUUM, REINDEX).


To find the biggest tables in terms of row estimates, table size, index size, and total size, you can query PostgreSQL system catalogs and use size-related functions like pg_table_size, pg_indexes_size, and pg_total_relation_size.

SELECT
    n.nspname AS schemaname,
    c.relname AS tablename,
    pg_size_pretty(pg_table_size(c.oid)) AS table_size, -- Table data size
    pg_size_pretty(pg_indexes_size(c.oid)) AS index_size, -- Indexes size
    pg_size_pretty(pg_total_relation_size(c.oid)) AS total_size, -- Total size (table + indexes + TOAST)
    c.reltuples::BIGINT AS row_estimate -- Estimated number of rows
FROM
    pg_class c
JOIN
    pg_namespace n ON n.oid = c.relnamespace
WHERE
    c.relkind = 'r' -- Regular tables only
    AND n.nspname NOT IN ('pg_catalog', 'information_schema') -- Exclude system schemas
ORDER BY
    pg_total_relation_size(c.oid) DESC -- Sort by total size
LIMIT 10; -- Get the top 10 biggest tables

If you want to analyze more details about indexes, you can join with pg_index or run a separate query like this:

SELECT
    n.nspname AS schemaname,
    c.relname AS indexname,
    pg_size_pretty(pg_relation_size(c.oid)) AS index_size,
    t.relname AS tablename
FROM
    pg_class c
JOIN
    pg_namespace n ON n.oid = c.relnamespace
JOIN
    pg_index i ON i.indexrelid = c.oid
JOIN
    pg_class t ON i.indrelid = t.oid
WHERE
    c.relkind = 'i' -- Only indexes
    AND n.nspname NOT IN ('pg_catalog', 'information_schema')
ORDER BY
    pg_relation_size(c.oid) DESC
LIMIT 10;

