
Analyze Table Bloat:
SELECT
    schemaname,
    relname AS tablename,
    pg_size_pretty(pg_relation_size(relid)) AS total_size,
    pg_size_pretty(pgstattuple.relpages * 8192) AS live_data,
    pg_size_pretty(pgstattuple.dead_tuple_len) AS dead_tuples,
    pgstattuple.dead_tuple_percent AS dead_tuple_percent
FROM
    pg_stat_all_tables
JOIN
    pgstattuple((schemaname || '.' || relname)::regclass) AS pgstattuple
WHERE
    schemaname NOT IN ('pg_catalog', 'information_schema')
ORDER BY
    pgstattuple.dead_tuple_percent DESC
LIMIT 10;


Analyze Index Bloat:

SELECT
    schemaname,
    relname AS indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS total_size,
    pg_size_pretty(pgstattuple.dead_tuple_len) AS dead_tuples,
    pgstattuple.dead_tuple_percent AS dead_tuple_percent
FROM
    pg_stat_all_indexes
JOIN
    pgstattuple((schemaname || '.' || indexrelname)::regclass) AS pgstattuple
WHERE
    schemaname NOT IN ('pg_catalog', 'information_schema')
ORDER BY
    pgstattuple.dead_tuple_percent DESC
LIMIT 10;




Using pg_bloat_check (Automated and Comprehensive)
pg_bloat_check is a script that estimates bloat in tables and indexes by analyzing system catalogs and applying a bloat formula. You do not need to install it in the database; it can be run as a script using SQL queries.


WITH bloat_data AS (
    SELECT
        schemaname,
        tablename,
        reltuples AS estimated_rows,
        relpages AS pages,
        pg_relation_size(relid) AS table_size,
        pg_total_relation_size(relid) AS total_size,
        pg_total_relation_size(relid) - pg_relation_size(relid) AS bloat_size,
        CASE
            WHEN pg_relation_size(relid) > 0 THEN
                (pg_total_relation_size(relid) - pg_relation_size(relid)) * 100.0 / pg_total_relation_size(relid)
            ELSE 0
        END AS bloat_percent
    FROM
        pg_stat_all_tables
    JOIN
        pg_class ON relid = pg_class.oid
    WHERE
        schemaname NOT IN ('pg_catalog', 'information_schema')
)
SELECT
    schemaname,
    tablename,
    pg_size_pretty(table_size) AS table_size,
    pg_size_pretty(bloat_size) AS bloat_size,
    bloat_percent
FROM
    bloat_data
WHERE
    bloat_percent > 10 -- Threshold for bloat
ORDER BY
    bloat_percent DESC;

for index:

WITH index_bloat AS (
    SELECT
        schemaname,
        indexrelname AS indexname,
        reltuples AS estimated_rows,
        pg_relation_size(indexrelid) AS index_size,
        pg_relation_size(indexrelid) - (pg_stat.get_live_tuples(indexrelid) * pg_index_tuple_estimate(indexrelid)) AS bloat_size,
        CASE
            WHEN pg_relation_size(indexrelid) > 0 THEN
                (pg_relation_size(indexrelid) - (pg_stat.get_live_tuples(indexrelid) * pg_index_tuple_estimate(indexrelid))) * 100.0 / pg_relation_size(indexrelid)
            ELSE 0
        END AS bloat_percent
    FROM
        pg_stat_all_indexes
    JOIN
        pg_class c ON c.oid = indexrelid
    WHERE
        schemaname NOT IN ('pg_catalog', 'information_schema')
)
SELECT
    schemaname,
    indexname,
    pg_size_pretty(index_size) AS index_size,
    pg_size_pretty(bloat_size) AS bloat_size,
    bloat_percent
FROM
    index_bloat
WHERE
    bloat_percent > 10 -- Threshold for bloat
ORDER BY
    bloat_percent DESC;


Use Built-In Views for Quick Estimation
If installing extensions is not allowed and you need an approximate result:

Use pg_stat_all_tables, pg_stat_all_indexes, and size functions (pg_table_size, pg_total_relation_size).

SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_table_size(relid)) AS total_size,
    pg_size_pretty(pg_total_relation_size(relid) - pg_table_size(relid)) AS bloat_size,
    CASE
        WHEN pg_table_size(relid) > 0 THEN
            (pg_total_relation_size(relid) - pg_table_size(relid)) * 100.0 / pg_table_size(relid)
        ELSE 0
    END AS bloat_percentage
FROM
    pg_stat_all_tables
WHERE
    schemaname NOT IN ('pg_catalog', 'information_schema')
ORDER BY
    bloat_percentage DESC
LIMIT 10;


VACUUM FULL schema1.tablename;
REINDEX INDEX schema1.indexname;

SELECT
    schemaname,
    relname AS tablename,
    indexrelname AS indexname,
    idx_scan AS index_scans
FROM
    pg_stat_user_indexes
WHERE
    idx_scan = 0; -- Never used


Best Practices for Long-Term Maintenance
Enable Autovacuum: Ensure autovacuum is running and configured properly.
Schedule Regular Maintenance:
Use VACUUM, ANALYZE, and REINDEX at off-peak hours.
Monitor Storage Usage:
Use pg_stat_all_tables, pg_stat_all_indexes, and pgstattuple regularly.
Archive Old Data: Move old data to separate tables or databases.
Using pgstattuple is the most accurate, but if extensions are restricted, rely on approximate catalog-based queries with manual fixes (VACUUM, REINDEX).
